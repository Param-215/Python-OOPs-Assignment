# -*- coding: utf-8 -*-
"""Python OOPs Assignment Questions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gofl1qkKFGjjeY6AjYKtpvZnOEK5zWMt

1. What is Object-Oriented Programming (OOP)?
A programming paradigm based on objects that contain data (attributes) and methods.

2. What is a class in OOP?
A blueprint for creating objects; it defines attributes and methods.

3. What is an object in OOP?
An instance of a class containing real data.

4. Difference between abstraction and encapsulation?

Abstraction: Hides implementation, shows only essential features.
Encapsulation: Bundles data and methods, restricting direct access.

5. What are dunder methods in Python?
Special methods with double underscores (e.g., __init__, __str__).

6. Explain inheritance in OOP.
A class can inherit attributes and methods from another class.

7. What is polymorphism in OOP?
Ability of the same method name to behave differently based on the object.

8. How is encapsulation achieved in Python?
Using private/protected variables (_var, __var) and getter/setter methods.

9. What is a constructor in Python?
The __init__ method that initializes object attributes.

10. What are class and static methods in Python?

Class method: Works with class (@classmethod).
Static method: Utility method not tied to class or object (@staticmethod).

11. What is method overloading in Python?
Not directly supported, but can be mimicked using default arguments.

12. What is method overriding in OOP?
Redefining a parent class method in a child class.

13. What is a property decorator in Python?
@property allows methods to be accessed like attributes.

14. Why is polymorphism important in OOP?
It increases flexibility and reusability of code.

15. What is an abstract class in Python?
A class with abstract methods (using abc module) that cannot be instantiated.

16. Advantages of OOP?
Modularity, reusability, abstraction, encapsulation, inheritance, polymorphism.

17. Difference between class variable and instance variable?
Class variable: Shared across all objects.
Instance variable: Unique to each object.

18. What is multiple inheritance in Python?
A class can inherit from more than one parent class.

19. Purpose of __str__ and __repr__ methods?
__str__: User-friendly string representation.
__repr__: Official/debug string representation.

20. Significance of super() function in Python?
Used to call parent class methods in a child class.

21. Significance of the __del__ method?
Destructor, called when an object is deleted.

22. Difference between @staticmethod and @classmethod?
@staticmethod: No access to class/object.
@classmethod: Has access to class (cls).

23. How does polymorphism work in Python with inheritance?
Child class overrides parent methods, and the correct method is chosen at runtime.

24. What is method chaining in Python OOP?
Calling multiple methods on the same object in one line (obj.method1().method2()).

25. Purpose of the __call__ method in Python?
Makes an object callable like a function.
"""

from abc import ABC, abstractmethod
# 1. Animal -> Dog (Override speak)
class Animal:
    def speak(self):
        print("This is an animal sound.")

class Dog(Animal):
    def speak(self):
        print("Bark!")

print("\n1. Animal & Dog")
a = Animal(); a.speak()
d = Dog(); d.speak()

# 2. Abstract class Shape
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, r):
        self.r = r
    def area(self):
        return 3.14 * self.r * self.r

class Rectangle(Shape):
    def __init__(self, l, w):
        self.l = l
        self.w = w
    def area(self):
        return self.l * self.w

print("\n2. Shape areas")
print("Circle area:", Circle(5).area())
print("Rectangle area:", Rectangle(4, 6).area())

# 3. Multi-level inheritance
class Vehicle:
    def __init__(self, type):
        self.type = type

class Car(Vehicle):
    def __init__(self, type, brand):
        super().__init__(type)
        self.brand = brand

class ElectricCar(Car):
    def __init__(self, type, brand, battery):
        super().__init__(type, brand)
        self.battery = battery
        print(f"ElectricCar created: {self.type}, {self.brand}, {self.battery}")

print("\n3. ElectricCar")
ec = ElectricCar("4-wheeler", "Tesla", "100 kWh")

# 4. Polymorphism Bird
class Bird:
    def fly(self):
        print("Some birds can fly.")

class Sparrow(Bird):
    def fly(self):
        print("Sparrow flies high.")

class Penguin(Bird):
    def fly(self):
        print("Penguins cannot fly.")

print("\n4. Birds")
Sparrow().fly()
Penguin().fly()

# 5. Encapsulation
class BankAccount:
    def __init__(self, balance=0):
        self.__balance = balance
    def deposit(self, amount):
        self.__balance += amount
        print(f"Deposited {amount}, New Balance: {self.__balance}")
    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew {amount}, New Balance: {self.__balance}")
        else:
            print("Insufficient balance")
    def check_balance(self):
        print("Balance:", self.__balance)

print("\n5. BankAccount")
acc = BankAccount(1000)
acc.deposit(500)
acc.withdraw(200)
acc.check_balance()

# 6. Runtime Polymorphism
class Instrument:
    def play(self):
        print("Playing an instrument")

class Guitar(Instrument):
    def play(self):
        print("Strumming guitar")

class Piano(Instrument):
    def play(self):
        print("Playing piano")

print("\n6. Instruments")
Guitar().play()
Piano().play()

# 7. Class & Static Methods
class MathOperations:
    @classmethod
    def add_numbers(cls, a, b):
        print("Addition:", a + b)
        return a + b
    @staticmethod
    def subtract_numbers(a, b):
        print("Subtraction:", a - b)
        return a - b

print("\n7. MathOperations")
MathOperations.add_numbers(5, 3)
MathOperations.subtract_numbers(10, 4)

# 8. Person count
class Person:
    count = 0
    def __init__(self, name):
        self.name = name
        Person.count += 1
        print(f"Person created: {self.name}, Total: {Person.count}")
    @classmethod
    def total_persons(cls):
        return cls.count

print("\n8. Persons count")
p1 = Person("Param")
p2 = Person("Rahul")

# 9. Fraction
class Fraction:
    def __init__(self, num, den):
        self.num = num
        self.den = den
    def __str__(self):
        return f"{self.num}/{self.den}"

print("\n9. Fraction")
print(Fraction(3, 4))

# 10. Operator overloading
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    def __str__(self):
        return f"({self.x}, {self.y})"

print("\n10. Vectors")
print(Vector(2, 3) + Vector(4, 5))

# 11. Person greet()
class PersonGreet:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

print("\n11. Greeting")
PersonGreet("Param", 21).greet()

# 12. Student average grade
class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades
    def average_grade(self):
        avg = sum(self.grades) / len(self.grades)
        print(f"{self.name}'s Average Grade:", avg)
        return avg

print("\n12. Student")
Student("Param", [85, 90, 78]).average_grade()

# 13. Rectangle area
class RectangleShape:
    def set_dimensions(self, l, w):
        self.l = l
        self.w = w
    def area(self):
        print("Rectangle area:", self.l * self.w)
        return self.l * self.w

print("\n13. Rectangle area")
r = RectangleShape()
r.set_dimensions(5, 4)
r.area()

# 14. Employee & Manager
class Employee:
    def calculate_salary(self, hours, rate):
        return hours * rate

class Manager(Employee):
    def calculate_salary(self, hours, rate, bonus):
        total = super().calculate_salary(hours, rate) + bonus
        print("Manager Salary:", total)
        return total

print("\n14. Manager salary")
Manager().calculate_salary(40, 100, 5000)

# 15. Product
class Product:
    def __init__(self, name, price, qty):
        self.name = name
        self.price = price
        self.qty = qty
    def total_price(self):
        total = self.price * self.qty
        print(f"Total price of {self.name}: {total}")
        return total

print("\n15. Product total price")
Product("Laptop", 50000, 2).total_price()

# 16. Abstract Animal -> Cow, Sheep
class AnimalAbstract(ABC):
    @abstractmethod
    def sound(self):
        pass

class Cow(AnimalAbstract):
    def sound(self):
        return "Moo"

class Sheep(AnimalAbstract):
    def sound(self):
        return "Baa"

print("\n16. Cow & Sheep")
print("Cow:", Cow().sound())
print("Sheep:", Sheep().sound())

# 17. Book
class Book:
    def __init__(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year
    def get_book_info(self):
        info = f"{self.title} by {self.author}, {self.year}"
        print("Book Info:", info)
        return info

print("\n17. Book info")
Book("Python Basics", "Param", 2025).get_book_info()

#18. House -> Mansion
class House:
    def __init__(self, address, price):
        self.address = address
        self.price = price

class Mansion(House):
    def __init__(self, address, price, rooms):
        super().__init__(address, price)
        self.rooms = rooms
        print(f"Mansion created at {self.address}, Price: {self.price}, Rooms: {self.rooms}")

print("\n18. Mansion")
Mansion("Mumbai", 50000000, 20)